
// error solved - 
//       while (!vif.drv_cb.PREADY) @(vif.drv_cb);
// 		@(vif.drv_cb); //this delay after ready is not required

//error got - but ready stays for a cycle after psel,enable is deasserted

// Code your design here

//DATE   - 2nd Aug, 2025
//AUTHOR - Nitish Gobinda Panda
//COMPANY- Scaledge
//PROJECT- APB_SLAVE_RTL/DUT code

module APB_DUT(PCLK,PRESETn,PADDR,PPROT,PSELx,PENABLE,PWRITE,PWDATA,PSTRB,PREADY,PRDATA,PSLVERR,PWAKEUP);

  parameter DATA_WIDTH =  8;
  parameter ADDR_WIDTH =  8;
  parameter STRB_WIDTH =  (DATA_WIDTH/8);
  parameter DEPTH      =  2**ADDR_WIDTH;

  localparam IDLE      =  3'b001;
  localparam SETUP     =  3'b010;
  localparam ACCESS    =  3'b100;
  
  input                       PCLK, PRESETn, PSELx, PENABLE, PWRITE, PWAKEUP;
  input      [ADDR_WIDTH-1:0] PADDR;
  input      [2:0]            PPROT;
  input      [DATA_WIDTH-1:0] PWDATA;
  input      [STRB_WIDTH-1:0] PSTRB;
  output reg [DATA_WIDTH-1:0] PRDATA;
  output reg                  PREADY, PSLVERR;
  
  reg        [DATA_WIDTH-1:0] rdata;
  reg                         err,ready;

  reg [7:0]                   mem [DEPTH-1:0];
  reg [ADDR_WIDTH-1:0]        ALIGN_ADDR;

  reg [2:0]                   n_s,p_s;

  integer                     i,j,k,m;

  function reg[7:0] crc(input reg[DATA_WIDTH-1:0] a);
    begin
      a[DATA_WIDTH-8 +:8]=0;
      for(m=0;m<DATA_WIDTH-8;m=m+8)begin
        a[DATA_WIDTH-8 +:8]=a[DATA_WIDTH-8 +:8]^a[m+:8];
      end
      crc=a[DATA_WIDTH-8 +:8];
    end
  endfunction

  always @(posedge PCLK or negedge PRESETn)begin
    if(!PRESETn)begin
      p_s<=IDLE;
      n_s<=IDLE;
      PSLVERR<=0;
      PREADY<=0;
      PRDATA<=0;

      for(i=0;i<DEPTH;i++) mem[i]<=0;
    end
    else begin
      p_s<=n_s;
    end
  end

  always@(*)begin
      case(p_s)
        IDLE : begin
          if(PSELx ) begin
            n_s<=SETUP;
              PSLVERR<=0;
              PREADY<=0;
              PRDATA<=0;
            //    PSTRB[STRB_WIDTH-1]<=1; //crc
          end
          else begin
            n_s<=IDLE;          
            PSLVERR<=0;
            PREADY<=0;
            PRDATA<=0;
          end
        end

        SETUP : begin
          if(PSELx ) begin
            if(PENABLE) begin
              n_s<=ACCESS;
              PSLVERR<=0;
              PREADY<=0;
              PRDATA<=0;

// 	          PREADY<=1;  // transfer without wait states
            end
            else begin
              n_s<=SETUP;
              PSLVERR<=0;
              PREADY<=0;
              PRDATA<=0;
            end
          end
          else begin
            n_s<=IDLE;
            PSLVERR<=0;
            PREADY<=0;
            PRDATA<=0;
          end
        end

        ACCESS : begin
//           PREADY<=1; //with wait states
//           ALIGN_ADDR=PADDR<<$clog2(STRB_WIDTH); //aligned addr
          ALIGN_ADDR=PADDR-(PADDR%STRB_WIDTH); //aligned addr
          if(PSELx) begin
            if(PENABLE)begin
          PREADY<=1; //with wait states
              if(ALIGN_ADDR[ADDR_WIDTH-1]==1) PSLVERR=1;
              else PSLVERR<=0;
              if(PWRITE) begin //write trns
//                   $display("%h",PWDATA);
                if(PWDATA[DATA_WIDTH-1 -:8]==crc(PWDATA)) PSLVERR<=0;//crc 
                else PSLVERR<=1;//crc mismatch
              $display("%h %h %h %b",ALIGN_ADDR, mem[ALIGN_ADDR],PWDATA,PSTRB);
                  write_transfer();
                end
               else PSLVERR<=1;//crc mismatch
              
              else begin //read transfer i.e, pwrite==0
                if(PSTRB==0) begin
                  read_transfer();
//               $display("%h %h %h %b",ALIGN_ADDR, mem[ALIGN_ADDR],PWDATA,PSTRB);
                end
                else PSLVERR<=1;//pstrb should be 0 in read
              end
              n_s<=SETUP;
//               PREADY<=0;
            end
            else begin
              n_s<=ACCESS;
//               PSLVERR<=0;
//               PREADY<=0;
//               PRDATA<=0;
            end
          end
          else begin
            n_s<=IDLE;
//             PSLVERR<=0;
//             PREADY<=0;
//             PRDATA<=0;
          end
        end
        default : n_s<=IDLE;
      endcase
    
  end

  
  task write_transfer();
    case(PPROT) //protection
      3'b000:begin //normal-unsecure-data_memory_space
        if(ALIGN_ADDR>=0*(DEPTH/8) && ALIGN_ADDR<1*(DEPTH/8)) begin
          for(j=0;j<STRB_WIDTH;j++)begin
            if(PSTRB[j] || j==STRB_WIDTH-1) begin
              mem[ALIGN_ADDR+j]<=PWDATA[8*j+:8];//narrow transfer
//               $strobe("%h %h %h %b",ALIGN_ADDR+j, mem[ALIGN_ADDR+j],PWDATA,PSTRB);
            end
          end
        end
        else PSLVERR<=1;
      end

      3'b001:begin //normal-unsecure-instr_memory_space
        if(ALIGN_ADDR>=1*(DEPTH/8) && ALIGN_ADDR<2*(DEPTH/8)) begin
          for(j=0;j<STRB_WIDTH;j++)begin
            if(PSTRB[j] || j==STRB_WIDTH-1) begin
              mem[ALIGN_ADDR+j]<=PWDATA[8*j+:8];//narrow transfer
            end
          end
        end
        else PSLVERR<=1;
      end

      3'b010:begin //normal-secure-data_memory_space
        if(ALIGN_ADDR>=2*(DEPTH/8) && ALIGN_ADDR<3*(DEPTH/8)) begin
          for(j=0;j<STRB_WIDTH;j++)begin
            if(PSTRB[j] || j==STRB_WIDTH-1) begin
              mem[ALIGN_ADDR+j]<=PWDATA[8*j+:8];//narrow transfer
            end
          end
        end
        else PSLVERR<=1;
      end

      3'b011:begin //normal-secure-instr_memory_space
        if(ALIGN_ADDR>=3*(DEPTH/8) && ALIGN_ADDR<4*(DEPTH/8)) begin
          for(j=0;j<STRB_WIDTH;j++)begin
            if(PSTRB[j] || j==STRB_WIDTH-1) begin
              mem[ALIGN_ADDR+j]<=PWDATA[8*j+:8];//narrow transfer
            end
          end
        end
        else PSLVERR<=1;
      end

      3'b100:begin //privilage-unsecure-data_memory_space
        if(ALIGN_ADDR>=4*(DEPTH/8) && ALIGN_ADDR<5*(DEPTH/8)) begin
          for(j=0;j<STRB_WIDTH;j++)begin
            if(PSTRB[j] || j==STRB_WIDTH-1) begin
              mem[ALIGN_ADDR+j]<=PWDATA[8*j+:8];//narrow transfer
            end
          end
        end
        else PSLVERR<=1;
      end

      3'b101:begin //privilage-unsecure-instr_memory_space
        if(ALIGN_ADDR>=5*(DEPTH/8) && ALIGN_ADDR<6*(DEPTH/8)) begin
          for(j=0;j<STRB_WIDTH;j++)begin
            if(PSTRB[j] || j==STRB_WIDTH-1) begin
              mem[ALIGN_ADDR+j]<=PWDATA[8*j+:8];//narrow transfer
            end
          end
        end
        else PSLVERR<=1;
      end

      3'b110:begin//privilage-secure-data_memory_space
        if(ALIGN_ADDR>=6*(DEPTH/8) && ALIGN_ADDR<7*(DEPTH/8)) begin
          for(j=0;j<STRB_WIDTH;j++)begin
            if(PSTRB[j] || j==STRB_WIDTH-1) begin
              mem[ALIGN_ADDR+j]<=PWDATA[8*j+:8];//narrow transfer
            end
          end
        end
        else PSLVERR<=1;
      end

      3'b111:begin //privilage-secure-instr_memory_space
        if(ALIGN_ADDR>=7*(DEPTH/8) && ALIGN_ADDR<8*(DEPTH/8)) begin
          for(j=0;j<STRB_WIDTH;j++)begin
            if(PSTRB[j] || j==STRB_WIDTH-1) begin
              mem[ALIGN_ADDR+j]<=PWDATA[8*j+:8];//narrow transfer
            end
          end
        end
        else PSLVERR<=1;
      end
      default : PSLVERR<=1;
    endcase
  endtask

   
  task read_transfer();
    case(PPROT) //protection
      3'b000:begin //normal-unsecure-data_memory_space
        if(ALIGN_ADDR>=0*(DEPTH/8) && ALIGN_ADDR<1*(DEPTH/8)) begin
          for(k=0;k<DATA_WIDTH/8;k++)begin
            PRDATA[(k+1)*8-1-:8]=mem[ALIGN_ADDR+k];
            $display("%h %h %h %b",ALIGN_ADDR+k, mem[ALIGN_ADDR+k], PRDATA,PSTRB);
          end
          PRDATA[DATA_WIDTH-8 +:8]=crc(PRDATA); //put crc while read cycle
        end
        else PSLVERR<=1;
      end

      3'b001:begin //normal-unsecure-instr_memory_space
        if(ALIGN_ADDR>=1*(DEPTH/8) && ALIGN_ADDR<2*(DEPTH/8)) begin
          for(k=0;k<DATA_WIDTH/8;k++)begin
            PRDATA[(k+1)*8-1-:8]=mem[ALIGN_ADDR+k];
          end
          PRDATA[DATA_WIDTH-8 +:8]=crc(PRDATA); //put crc while read cycle
        end
        else PSLVERR<=1;
      end

      3'b010:begin //normal-secure-data_memory_space
        if(ALIGN_ADDR>=2*(DEPTH/8) && ALIGN_ADDR<3*(DEPTH/8)) begin
          for(k=0;k<DATA_WIDTH/8;k++)begin
            PRDATA[(k+1)*8-1-:8]=mem[ALIGN_ADDR+k];
          end
          PRDATA[DATA_WIDTH-8 +:8]=crc(PRDATA); //put crc while read cycle
        end
        else PSLVERR<=1;
      end

      3'b011:begin //normal-secure-instr_memory_space
        if(ALIGN_ADDR>=3*(DEPTH/8) && ALIGN_ADDR<4*(DEPTH/8)) begin
          for(k=0;k<DATA_WIDTH/8;k++)begin
            PRDATA[(k+1)*8-1-:8]=mem[ALIGN_ADDR+k];
          end
          PRDATA[DATA_WIDTH-8 +:8]=crc(PRDATA); //put crc while read cycle
        end
        else PSLVERR<=1;
      end

      3'b100:begin //privilage-unsecure-data_memory_space
        if(ALIGN_ADDR>=4*(DEPTH/8) && ALIGN_ADDR<5*(DEPTH/8)) begin
          for(k=0;k<DATA_WIDTH/8;k++)begin
            PRDATA[(k+1)*8-1-:8]=mem[ALIGN_ADDR+k];
          end
          PRDATA[DATA_WIDTH-8 +:8]=crc(PRDATA); //put crc while read cycle
        end
        else PSLVERR<=1;
      end

      3'b101:begin //privilage-unsecure-instr_memory_space
        if(ALIGN_ADDR>=5*(DEPTH/8) && ALIGN_ADDR<6*(DEPTH/8)) begin
          for(k=0;k<DATA_WIDTH/8;k++)begin
            PRDATA[(k+1)*8-1-:8]=mem[ALIGN_ADDR+k];
          end
          PRDATA[DATA_WIDTH-8 +:8]=crc(PRDATA); //put crc while read cycle
        end
        else PSLVERR<=1;
      end

      3'b110:begin//privilage-secure-data_memory_space
        if(ALIGN_ADDR>=6*(DEPTH/8) && ALIGN_ADDR<7*(DEPTH/8)) begin
          for(k=0;k<DATA_WIDTH/8;k++)begin
            PRDATA[(k+1)*8-1-:8]=mem[ALIGN_ADDR+k];
          end
          PRDATA[DATA_WIDTH-8 +:8]=crc(PRDATA); //put crc while read cycle
        end
        else PSLVERR<=1;
      end

      3'b111:begin //privilage-secure-instr_memory_space
        if(ALIGN_ADDR>=7*(DEPTH/8) && ALIGN_ADDR<8*(DEPTH/8)) begin
          for(k=0;k<DATA_WIDTH/8;k++)begin
            PRDATA[(k+1)*8-1-:8]=mem[ALIGN_ADDR+k];
          end
          PRDATA[DATA_WIDTH-8 +:8]=crc(PRDATA); //put crc while read cycle
        end
        else PSLVERR<=1;
      end
      default : PSLVERR<=1;
    endcase
  endtask
  
endmodule
